# 深入理解JVM学习笔记

## 1 内存管理

### 1.1 运行时数据区域

![1586771622378](assets/1586771622378.png)

#### 1.1.1 程序计数器

**1. 概念**

程序计数器（Program Counter Register），是当前线程所执行的字节码的**行号指示器**。

> 线程私有的内存。

**2. 作用**

它是程序控制流的指示器，作用于以下基础功能：

- 分支
- 循环
- 跳转
- 异常处理
- 线程恢复

**3. 实现细节**

- 线程执行的是 Java 方法时，记录正在执行的虚拟机字节码指令的地址
- 线程执行本地（Native）方法时，计数器值为空（Undefined）

**4. 异常**

程序计数器是**唯一**一个在《Java虚拟机规范》中**没有**规定任何 **OutOfMemory Error** 情况的区域。

#### 1.1.2 Java虚拟机栈

**1. 概念**

Java 虚拟机栈（Java Virtual Machine Stack），是 Java 方法执行的线程内存模型。

> 线程私有的内存，生命周期与线程相同。

**2. 作用**

为 Java 方法（字节码）服务。

每个 Java 方法被执行时，Java 虚拟机栈会同步创建一个栈帧（Stack Frame），用于存储：

- 局部变量表
- 操作数栈
- 动态连接
- 方法出口

> 每个方法被调用至执行完毕的过程，对应一个栈帧在虚拟机中从入栈到出栈的过程。

**3. 异常**

- 抛出 StackOverflow Error 异常：线程请求的栈深度大于虚拟机允许的深度时。
- 抛出 OutOfMemory Error 异常：若 Java 虚拟机栈容量允许动态扩展，栈扩展无法申请到足够内存时。

> HotSpot 虚拟机的栈容量不允许动态扩展，所以它不会由于虚拟机无法扩展而导致 OutOfMemory Error 异常，但是线程申请空间失败会出现 OOM 异常。

##### 局部变量表

1）编译期的存放类型：

- Java 基本数据类型（boolean、byte、char、short、int、float、long、double）
- 对象引用（reference 类型，即【指向对象起始地址的引用指针】或【指向一个代表对象的句柄或与此对象相关的位置】）
- returnAddress 类型（指向字节码指令的地址）

2）编译期的存放方式：

以局部变量槽（Slot）表示

- 占用两个变量槽：long 和 double
- 占用一个变量槽：其余类型

> 局部变量表所需的内存空间在编译器期间分配完成，确定局部变量槽的数量，方法运行期间不会改变大小。

#### 1.1.3 本地方法栈

**1. 作用**

本地方法栈（Java Virtual Machine Stack），为本地（Native）方法服务。

>  线程私有的内存。

**2. 异常**

- 抛出 StackOverflow Error 异常：栈深度溢出时
- 抛出 OutOfMemory Error 异常：栈扩展失败时

#### 1.1.4 Java堆

**1. 概念**

Java 堆（Java Heap）虚拟机管理的内存中最大的一块，也叫做 GC 堆。

> 线程共享的区域，虚拟机启动时创建。

**2. 作用**

存放对象实例。

- 回收内存：分代回收（新生代、老板年代、永久代、Eden 空间、 From Survivor 空间、To Suvivor 空间）
- 分配内存：堆中划分多喝线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）来提升对象分配时的效率

> Java 堆可在物理内存空间上不连续，但是逻辑上是连续的。

**3. 异常**

抛出 OutOfMemory Error 异常：Java 堆没有内存分配实例，且堆也无法再次扩展时。

> Java 堆默认固定大小，但是可以通过参数 `-Xmx` 和 `-Xms` 扩展其大小。

#### 1.1.5 方法区

**1. 概念**

方法区（Method Area），堆的一个逻辑部分。

> 线程共享的区域。它也叫做“非堆”（Non-Heap），目的是与 Java 堆区分。

**2. 作用**

方法区（Method Area）存储虚拟机加载的数据：

- 类型信息
- 常量
- 静态变量
- 即时编译器编译后的代码缓存

**3. 实现方式**

使用永久代来实现方法区。

- 目的：省去了专门为方法区编写内存管理代码的工作，复用 HotSpot 的垃圾收集器管理方法区。
- 缺陷：永久代有 `-XX: MaxPermSize` 上限，默认固定大小，容易导致 Java 程序的内存溢出问题（极少数方法（如 `String::intern()` ）在不同虚拟机下有不同的表现）。

HotSpot虚拟机：

- JDK6 中放弃了永久代，逐步改为本地内存（Native Memory）实现方法区
- JDK7 移除永久代中的字符串常量池和静态变量
- JDK8 完全放弃永久代，本地内存中实现元空间（Metaspace）来代替

BEA JRockit、IBM J9 等其他虚拟机：

- 没有用永久代实现方法区，所以只要不触碰到物理可用内存上限就不会出现 OOM

> 方法区并不等价于“永久代”。

**4. 内存回收**

内存回收主要针对

- 常量池的回收
- 对类型的卸载

> 方法区与 Java 堆一样可在物理内存空间上不连续，但是逻辑上是连续的，甚至可以不实现垃圾收集。
>
> 方法区的回收条件苛刻，回收效果不理想，但有时必须回收。

**5. 异常**

抛出 OutOfMemory Error 异常：方法区无法满足新内存的分配时。

##### 运行时常量池

1）概念

运行时常量池（Runtime Constant Pool），方法区的一部分。

> 编译后的Class文件包含
>
> - 类的版本
> - 字段
> - 方法
> - 接口描述
> - 常量池表（Constant Pool Table）

常量池表用于存放编译期生成的各种

- 字面量
- 符号引用

2）作用

在类加载后存放

- 常量池表
- 符号引用翻译出来的直接引用

3）动态性

在运行期间也能将新的常量放入池中（如 String 类的 `intern()` 方法）。

4）异常

抛出 OutOfMemory Error 异常：受到方法区的限制，常量池无法申请到内存时。

### 1.2 直接内存

