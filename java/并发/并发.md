- [1 影响线程并发性的因素](#1-影响线程并发性的因素)
  - [1.1 上下文切换](#11-上下文切换)
  - [1.2 死锁](#12-死锁)
  - [1.3 资源限制](#13-资源限制)
- [2 并发机制的底层实现原理](#2-并发机制的底层实现原理)
  - [2.1 volatile](#21-volatile)
  - [2.2 synchronized](#22-synchronized)
  - [2.3 原子操作](#23-原子操作)



# java并发

## 1 影响线程并发性的因素

### 1.1 上下文切换

**1. 概念**

CPU在执行A任务后且在切换到B任务前，会保存A任务的状态，以便下次切回A任务时可以加载到这个任务的状态，这个从保存到再加载的过程就是上下文切换。

**2. 测试工具**

- Lmbench3 可以测量上下文切换的时长（工具）
- vmstat 可以测量上下文切换的次数（linux命令）

**3. 优化方案**

减少上下文切换的优化方案：

- 无锁并发编程：将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据
- CAS算法：Atomic包使用CAS算法更新数据，无需加锁
- 使用最少线程：避免创建不需要的线程
- 使用协程：单线程里实现多任务的调度，并再单线程里维持多个任务间的切换

### 1.2 死锁

**1. 概念**

两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

**2. 优化方案**

避免死锁的方式：

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 使用定时锁时，用lock.tryLock(timeout)来替代使用内部锁机制
- 数据库锁的加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

### 1.3 资源限制

**1. 概念**

程序的执行速度受限于计算机硬件资源或软件资源。

**2. 优化方案**

- 硬件资源限制：搭建服务器集群或使用ODPS、Hadoop，不同机器处理不同数据
- 软件资源限制：使用资源池将资源复用

## 2 并发机制的底层实现原理

### 2.1 volatile

**1. 概念**

Java线程内存模型将确保所有线程看到volatile修饰的变量的值是一致的。

**2. volatile底层实现原理**

- 被volatile修饰的共享变量进行写操作时汇编代码中会额外增加lock前缀指令。
- lock前缀指令在多处理器下的作用：
  - ①将当前处理器缓存行的数据写回到系统内存
  - ②此写回内存操作会使其他CPU里缓存的该内存地址数据失效（缓存一致性协议）

> 缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里

**3. 优化方案**

- 追加到64字节优化队列出队和入队的性能

> 不能使用此方案的两个场景：
>
> ①缓存行非64字节宽的处理器下
>
> ②共享变量不会被频繁地写

### 2.2 synchronized

**1. 表现形式**

- 对普通同步方法：锁是当前实例对象
- 对静态同步方法：锁是当前类的Class对象
- 对同步方法块：锁是Synchronized括号里配置的对象

**2. synchronized底层实现原理**



### 2.3 原子操作

**1. 概念**